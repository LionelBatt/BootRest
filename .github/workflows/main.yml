name: Travel Agency CI/CD with Maven and EC2 Deployment

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-west-3
  S3_BUCKET: prod-resto
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  APP_VERSION: 1.0.1-SNAPSHOT

jobs:
  test:
    runs-on: ubuntu-latest
    name: Tests et QualitÃ© du Code
    
    steps:
    - name: ğŸ“¥ Checkout du code
      uses: actions/checkout@v4

    - name: â˜• Configuration JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: ğŸ“¦ Cache des dÃ©pendances Maven
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: ğŸ§ª ExÃ©cution des tests
      run: mvn -B test --file pom.xml
      
  build:
    runs-on: ubuntu-latest
    needs: test
    name: Construction de l'application
    
    steps:
    - name: ğŸ“¥ Checkout du code
      uses: actions/checkout@v4

    - name: â˜• Configuration JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: ğŸ“¦ Cache des dÃ©pendances Maven
      uses: actions/cache@v4
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: ğŸ”¨ Construction avec Maven
      run: mvn -B package -DskipTests --file pom.xml

    - name: ğŸ“‹ VÃ©rification de l'artifact
      run: |
        ls -la target/
        echo "JAR crÃ©Ã©: $(ls target/*.jar | grep -v original)"

    - name: ğŸ’¾ Sauvegarde de l'artifact
      uses: actions/upload-artifact@v4
      with:
        name: travel-agency-jar
        path: target/travel-agency-${{ env.APP_VERSION }}.jar
        retention-days: 30

  deploy:
    runs-on: ubuntu-latest
    needs: build
    name: DÃ©ploiement sur EC2
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: ğŸ“¥ Checkout du code
      uses: actions/checkout@v4

    - name: ğŸ“¦ RÃ©cupÃ©ration de l'artifact
      uses: actions/download-artifact@v4
      with:
        name: travel-agency-jar
        path: ./

    - name: ğŸ”§ Configuration des credentials AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸª£ CrÃ©ation du bucket S3 temporaire
      run: |
        BUCKET_NAME="travel-agency-deploy-$(date +%Y%m%d%H%M%S)"
        echo "S3_BUCKET_TEMP=$BUCKET_NAME" >> $GITHUB_ENV
        
        # CrÃ©er le bucket
        aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }}
        
        # DÃ©sactiver le blocage d'accÃ¨s public
        aws s3api put-public-access-block \
          --bucket $BUCKET_NAME \
          --public-access-block-configuration \
          "BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false"
        
        # Configurer la politique pour accÃ¨s public temporaire
        aws s3api put-bucket-policy --bucket $BUCKET_NAME --policy '{
          "Version": "2012-10-17",
          "Statement": [
            {
              "Sid": "PublicReadGetObject",
              "Effect": "Allow",
              "Principal": "*",
              "Action": "s3:GetObject",
              "Resource": "arn:aws:s3:::'$BUCKET_NAME'/app/*"
            }
          ]
        }'
        
        echo "âœ… Bucket S3 temporaire crÃ©Ã©: $BUCKET_NAME"

    - name: ğŸ”‘ Configuration de la clÃ© SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $(aws ec2 describe-instances --instance-ids ${{ env.EC2_INSTANCE_ID }} --query 'Reservations[0].Instances[0].PublicIpAddress' --output text) >> ~/.ssh/known_hosts

    - name: ğŸ“¤ Upload JAR vers S3
      run: |
        aws s3 cp travel-agency-${{ env.APP_VERSION }}.jar s3://${{ env.S3_BUCKET_TEMP }}/app/
        echo "âœ… JAR uploadÃ© vers S3: ${{ env.S3_BUCKET_TEMP }}"

    - name: ğŸ“ CrÃ©ation du script de dÃ©ploiement
      run: |
        cat > deploy_embedded.sh << EOF
        #!/bin/bash
        set -e
        
        # Configuration
        APP_NAME="travel-agency"
        CONTAINER_NAME="travel-agency-app"
        IMAGE_NAME="travel-agency:latest"
        APP_DIR="/opt/travel-agency"
        LOGS_DIR="/var/log/travel-agency"
        DATA_DIR="/var/lib/travel-agency"
        S3_BUCKET="${{ env.S3_BUCKET_TEMP }}"
        AWS_REGION="${{ env.AWS_REGION }}"
        JAR_FILE="travel-agency-${{ env.APP_VERSION }}.jar"
        
        echo "ğŸš€ DÃ©but du dÃ©ploiement Travel Agency..."
        
        # CrÃ©er les rÃ©pertoires avec les bonnes permissions
        echo "ğŸ“ CrÃ©ation des rÃ©pertoires..."
        sudo mkdir -p "\$APP_DIR" "\$LOGS_DIR" "\$DATA_DIR"
        sudo chown -R ubuntu:ubuntu "\$APP_DIR"
        sudo chown -R 1000:1000 "\$LOGS_DIR" "\$DATA_DIR"
        sudo chmod -R 755 "\$LOGS_DIR" "\$DATA_DIR"
        cd "\$APP_DIR"
        
        # ArrÃªter et supprimer le conteneur existant
        if docker ps -q -f name="\$CONTAINER_NAME" | grep -q .; then
            echo "ğŸ›‘ ArrÃªt du conteneur existant..."
            docker stop "\$CONTAINER_NAME" || true
        fi
        
        if docker ps -aq -f name="\$CONTAINER_NAME" | grep -q .; then
            echo "ğŸ—‘ï¸ Suppression du conteneur existant..."
            docker rm "\$CONTAINER_NAME" || true
        fi
        
        # Supprimer l'ancienne image
        if docker images -q "\$IMAGE_NAME" | grep -q .; then
            echo "ğŸ—‘ï¸ Suppression de l'ancienne image..."
            docker rmi "\$IMAGE_NAME" || true
        fi
        
        # TÃ©lÃ©charger le JAR depuis S3
        echo "ğŸ“¥ TÃ©lÃ©chargement du JAR depuis S3..."
        JAR_URL="https://s3.\$AWS_REGION.amazonaws.com/\$S3_BUCKET/app/\$JAR_FILE"
        echo "ğŸ”— URL: \$JAR_URL"
        
        curl -f -L -o "\$JAR_FILE" "\$JAR_URL"
        
        # VÃ©rifier le tÃ©lÃ©chargement
        if [[ ! -f "./\$JAR_FILE" ]]; then
            echo "âŒ Erreur: JAR non tÃ©lÃ©chargÃ©"
            exit 1
        fi
        
        echo "âœ… JAR tÃ©lÃ©chargÃ©: \$(ls -lh \$JAR_FILE)"
        
        # VÃ©rifier l'intÃ©gritÃ© du JAR
        echo "ğŸ” VÃ©rification de l'intÃ©gritÃ© du JAR..."
        if java -jar "\$JAR_FILE" --help >/dev/null 2>&1; then
            echo "âœ… JAR valide"
        else
            echo "âš ï¸ JAR potentiellement corrompu, on continue..."
        fi
        
        # CrÃ©er le Dockerfile avec plus de diagnostic
        echo "ğŸ“ CrÃ©ation du Dockerfile..."
        cat > Dockerfile << 'DOCKERFILE_END'
        FROM openjdk:21-jdk-slim
        
        # Installer des outils de diagnostic
        RUN apt-get update && apt-get install -y curl procps && rm -rf /var/lib/apt/lists/*
        
        # CrÃ©er l'utilisateur avec UID/GID spÃ©cifiques
        RUN groupadd -g 1000 appuser && useradd -u 1000 -g appuser -m appuser
        
        WORKDIR /app
        RUN mkdir -p /app/logs /app/data && chown -R appuser:appuser /app
        
        # Copier le JAR
        COPY travel-agency-1.0.1-SNAPSHOT.jar app.jar
        RUN chown appuser:appuser app.jar
        
        # VÃ©rifier le JAR dans le conteneur
        RUN java -jar app.jar --help || echo "JAR check failed but continuing..."
        
        USER appuser
        
        EXPOSE 8080
        VOLUME ["/app/logs", "/app/data"]
        
        # Variables d'environnement avec valeurs par dÃ©faut
        ENV SERVER_PORT=8080 \
            LOGGING_LEVEL_ROOT=INFO \
            LOGGING_FILE_PATH=/app/logs/application.log \
            JAVA_OPTS="-Xms256m -Xmx512m -XX:+UseG1GC" \
            SPRING_PROFILES_ACTIVE=prod
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=10s --start-period=120s --retries=3 \
            CMD curl -f http://localhost:\$SERVER_PORT/actuator/health || exit 1
        
        # Script d'entrÃ©e avec plus de logs
        ENTRYPOINT ["sh", "-c", "echo 'Starting application with JAVA_OPTS:' \$JAVA_OPTS && echo 'Java version:' && java -version && echo 'Starting JAR...' && java \$JAVA_OPTS -jar /app/app.jar"]
        DOCKERFILE_END
        
        # Construire l'image Docker
        echo "ğŸ”¨ Construction de l'image Docker..."
        docker build -t "\$IMAGE_NAME" . --no-cache
        
        # VÃ©rifier que l'image a Ã©tÃ© crÃ©Ã©e
        if ! docker images -q "\$IMAGE_NAME" | grep -q .; then
            echo "âŒ Erreur: Image Docker non crÃ©Ã©e"
            exit 1
        fi
        
        echo "âœ… Image Docker crÃ©Ã©e"
        
        # Afficher les variables d'environnement disponibles
        echo "ğŸ” Variables d'environnement disponibles:"
        env | grep -E "(DB_|JWT_|MAIL_)" || echo "Aucune variable d'environnement configurÃ©e"
        
        # DÃ©marrer le conteneur avec configuration Ã©tendue
        echo "ğŸš€ DÃ©marrage du conteneur..."
        docker run -d \
            --name "\$CONTAINER_NAME" \
            --restart unless-stopped \
            -p 8080:8080 \
            -v "\$LOGS_DIR:/app/logs:rw" \
            -v "\$DATA_DIR:/app/data:rw" \
            -e SERVER_PORT=8080 \
            -e LOGGING_FILE_PATH=/app/logs/application.log \
            -e LOGGING_LEVEL_ROOT=DEBUG \
            -e SPRING_PROFILES_ACTIVE=prod \
            -e "DB_URL=\${DB_URL:-jdbc:h2:mem:testdb}" \
            -e "DB_USER=\${DB_USER:-sa}" \
            -e "DB_PASSWORD=\${DB_PASSWORD:-}" \
            -e "JWT_SECRET=\${JWT_SECRET:-defaultsecretkey12345678901234567890}" \
            -e "MAIL_HOST=\${MAIL_HOST:-smtp.gmail.com}" \
            -e "MAIL_PORT=\${MAIL_PORT:-587}" \
            -e "MAIL_USER=\${MAIL_USER:-}" \
            -e "MAIL_PASSWORD=\${MAIL_PASSWORD:-}" \
            "\$IMAGE_NAME"
        
        # Attendre un peu et vÃ©rifier le statut
        echo "â³ Attente du dÃ©marrage (30 secondes)..."
        sleep 30
        
        # Diagnostic complet
        echo "ğŸ” Diagnostic du conteneur:"
        echo "Status:"
        docker ps -a -f name="\$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        echo -e "\nğŸ“ Logs du conteneur (50 derniÃ¨res lignes):"
        docker logs --tail 50 "\$CONTAINER_NAME" 2>&1
        
        echo -e "\nğŸ’¾ VÃ©rification des volumes:"
        echo "Logs directory: \$(ls -la \$LOGS_DIR/ 2>/dev/null | head -5)"
        echo "Data directory: \$(ls -la \$DATA_DIR/ 2>/dev/null | head -5)"
        
        # VÃ©rifier si le conteneur tourne
        if docker ps | grep "\$CONTAINER_NAME" > /dev/null; then
            echo "âœ… Conteneur en cours d'exÃ©cution"
            PUBLIC_IP=\$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4 2>/dev/null || echo "N/A")
            echo "ğŸŒ Application potentiellement disponible sur : http://\$PUBLIC_IP:8080/travel"
            
            # Test de connectivitÃ© local
            echo "ğŸ”— Test de connectivitÃ© locale:"
            if curl -f -m 10 http://localhost:8080/actuator/health 2>/dev/null; then
                echo "âœ… Application rÃ©pond localement"
            else
                echo "âš ï¸ Application ne rÃ©pond pas encore localement"
            fi
            
        else
            echo "âŒ Conteneur ne fonctionne pas correctement"
            
            # Diagnostic avancÃ©
            echo -e "\nğŸ” Diagnostic avancÃ©:"
            echo "Images Docker:"
            docker images | grep travel-agency
            
            echo -e "\nTous les conteneurs:"
            docker ps -a
            
            echo -e "\nLogs complets du conteneur:"
            docker logs "\$CONTAINER_NAME" 2>&1 || echo "Pas de logs disponibles"
            
            echo -e "\nInspection du conteneur:"
            docker inspect "\$CONTAINER_NAME" | jq '.[] | {Status: .State, Mounts: .Mounts}' 2>/dev/null || docker inspect "\$CONTAINER_NAME"
            
            exit 1
        fi
        
        echo "ğŸ‰ DÃ©ploiement terminÃ© !"
        EOF
        
        chmod +x deploy_embedded.sh

    - name: ğŸš€ DÃ©ploiement sur EC2
      run: |
        # RÃ©cupÃ©rer l'IP publique de l'instance EC2
        EC2_IP=$(aws ec2 describe-instances \
          --instance-ids ${{ env.EC2_INSTANCE_ID }} \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "ğŸŒ IP de l'instance EC2: $EC2_IP"
        echo "ğŸ”‘ DÃ©ploiement via SSH..."
        
        # ExÃ©cuter via SSH
        scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no deploy_embedded.sh ubuntu@$EC2_IP:/tmp/
        ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ubuntu@$EC2_IP "bash /tmp/deploy_embedded.sh"
        
        echo "ğŸ‰ DÃ©ploiement terminÃ© avec succÃ¨s !"

    - name: ğŸ§¹ Nettoyage du bucket temporaire
      if: always()
      run: |
        if [ ! -z "${{ env.S3_BUCKET_TEMP }}" ]; then
          echo "ğŸ§¹ Suppression du bucket temporaire: ${{ env.S3_BUCKET_TEMP }}"
          aws s3 rm s3://${{ env.S3_BUCKET_TEMP }} --recursive || true
          aws s3 rb s3://${{ env.S3_BUCKET_TEMP }} || true
          echo "âœ… Bucket temporaire supprimÃ©"
        fi
